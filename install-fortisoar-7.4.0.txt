#!/bin/bash
# Copyright start
# Copyright (C) 2008 - 2023 Fortinet Inc.
# All rights reserved.
# FORTINET CONFIDENTIAL & FORTINET PROPRIETARY SOURCE CODE
# Copyright end

# -------------------------- Utility Functions ---------------------------------

# Executes the command and exits with error if it fails
my_system(){
    echo "Running: $*"
    $*
    if [ $? -ne 0 ];then
        echo "Error running: $*"
        my_exit 1
    fi
}

# The my_exit() function is common.
my_exit() {
    exit $1
}

usage() {
    echo ""
    echo "$0 utility is used to install the FotiSOAR Application"
    echo "Usage:"
    echo "[--ignore-ssl-check]               - use this option to ignore SSL check while installing FortiSOAR"
    echo "[--skip-sfsp]                      - use this option to skip to install SOAR framework solution pack"
    echo "[--help]                           - Shows the help message and exit"
    my_exit 1
}

check_if_rhel() {
    local os_flavor=$(cat /etc/redhat-release | cut -d ' ' -f 1-4)
    local os_rh="Red Hat Enterprise Linux"
    if [ "$os_flavor" == "$os_rh" ]; then
        flag_is_rhel="true"
    fi
}

# The check_root() function check the logged in user is root or not.
check_root() {
    if [ $EUID -ne 0 ]; then
        echo "You should have "'"root"'" access to execute the $0 file."
        exit 1
    fi
}

# -------------------------- Utility Functions End -----------------------------

# After installing the "install-fortisoar.sh" script,
# if the user logs in with a different user (other than csadmin) and config-vm is not run, then display the warning message.
# This non_csadmin_user_login() function makes the entry of check_csadmin_user.sh script call with
# check_csadmin_user() function in /etc/bashrc file. File path: /opt/cyops/scripts/check_csadmin_user.sh
non_csadmin_user_login() {

    local f_check_csadmin_user="/opt/cyops/scripts/check_csadmin_user.sh"
    local f_base_name=$(basename "$f_check_csadmin_user")
    local f_bashrc="/etc/bashrc"

    grep -wq "$f_base_name" $f_bashrc
    if [ $? -ne 0 ]; then
        echo -e ". /${f_check_csadmin_user}" >>$f_bashrc
        echo -e "check_csadmin_user" >>$f_bashrc
    fi
}

#
# The add_sudoers_for_root() function add the sudo permission for nginx, postgres users and selected commands.
#
add_sudoers_for_root() {
    #
    # We use below command as sudo -u fsr-integrations.
    #
    local cmds_as_fsr_integrations="root   ALL=(fsr-integrations) NOPASSWD: /opt/cyops-integrations/.env/bin/python3"
    echo "$cmds_as_fsr_integrations" >>$sudoers

    #
    # We use below command as sudo -u nginx.
    #
    local cmds_as_nginx="root   ALL=(nginx) NOPASSWD: /opt/cyops-integrations/.env/bin/python3"
    cmds_as_nginx="$cmds_as_nginx, /bin/php"
    cmds_as_nginx="$cmds_as_nginx, /opt/cyops-workflow/.env/bin/pip"
    cmds_as_nginx="$cmds_as_nginx, SETENV: /opt/cyops-auth/.env/bin/python3"
    cmds_as_nginx="$cmds_as_nginx, /bin/rm -rf /var/www/cybersponse/app/cache/*"
    cmds_as_nginx="$cmds_as_nginx, /bin/touch"
    cmds_as_nginx="$cmds_as_nginx, /opt/cyops-routing-agent/.env/bin/python3"
    cmds_as_nginx="$cmds_as_nginx, /opt/cyops-search/.env/bin/python"
    cmds_as_nginx="$cmds_as_nginx, /opt/cyops-workflow/.env/bin/python3"

    echo "$cmds_as_nginx" >>$sudoers

    #
    # We use below command as sudo -u postgres.
    #
    local cmds_as_postgres="root   ALL=(postgres) NOPASSWD: /bin/psql"
    cmds_as_postgres="$cmds_as_postgres, /usr/pgsql-14/bin/pg_upgrade"
    cmds_as_postgres="$cmds_as_postgres, /bin/bash"
    cmds_as_postgres="$cmds_as_postgres, /bin/createdb"

    echo "$cmds_as_postgres" >>$sudoers

    #
    # We use below commands as sudo.
    #
    local cmds_as_root="root ALL=(root) NOPASSWD:/sbin/dmidecode"
    cmds_as_root="$cmds_as_root, /sbin/halt"
    cmds_as_root="$cmds_as_root, /bin/rm"
    cmds_as_root="$cmds_as_root, /bin/sh"
    cmds_as_root="$cmds_as_root, /bin/timeout"
    cmds_as_root="$cmds_as_root, /bin/csadm"
    cmds_as_root="$cmds_as_root, /bin/touch"
    cmds_as_root="$cmds_as_root, /bin/cat"
    cmds_as_root="$cmds_as_root, /bin/sed"
    cmds_as_root="$cmds_as_root, /bin/cp"
    cmds_as_root="$cmds_as_root, /sbin/restorecon"
    cmds_as_root="$cmds_as_root, /bin/keytool"
    cmds_as_root="$cmds_as_root, /bin/yum"
    cmds_as_root="$cmds_as_root, /bin/mkdir"
    cmds_as_root="$cmds_as_root, /bin/chmod"
    cmds_as_root="$cmds_as_root, /bin/chown"
    cmds_as_root="$cmds_as_root, /bin/echo"
    cmds_as_root="$cmds_as_root, /sbin/sysctl"
    cmds_as_root="$cmds_as_root, /bin/systemctl"

    echo "$cmds_as_root" >>$sudoers
}

# The update_environment_file function updates entry in the file /etc/environment with custom_yum_url variable value.
# Also, this function calls in cleanup function because cyops rpm package added the entry of \
# s_product_yum_server=repo.fortisoar.fortinet.com. So to change the value of s_product_yum_server variable \
# update_environment_file function calls in cleanup function.
#
return_status() {
    local f_file_name=$1
    local i_flag_status=$2

    if [ $i_flag_status -ne 0 ]; then
        echo -e "Failed to update the \"$i_flag_status\" file. Check if the \"$i_flag_status\" file has write permission."
    fi
}

update_environment_file() {
    grep -wq "$s_product_yum_server_old" $f_etc_environment
    if [ $? -eq 0 ]; then
        sed -i "/product_yum_server/c\product_yum_server=$custom_yum_url" $f_etc_environment
        return_status $f_etc_environment $?
        return
    fi
    echo "product_yum_server=$custom_yum_url" >>$f_etc_environment
}

#
# If organization has it's own yum repository then \
# organization can change default repository using the following function.
# The custom_yum_url variable export before run the script.
#
custom_yum_repo() {
    local f_product_yum_repo="/etc/yum/vars/product_yum_server"

    echo "$custom_yum_url" >$f_product_yum_repo
    if [ $? -ne 0 ]; then
        echo "Failed to update the $f_product_yum_repo file. Check if the $f_product_yum_repo file has write permission."
    fi
}

# The update_pip_conf function update the yum repository address for playbook execution.
update_pip_conf() {
    local a_pip_dirs=("integrations workflow")
    local f_pip_conf=""
    local s_extra_index_url="extra-index-url"
    local s_index_url="index-url"
    for dir_name in $a_pip_dirs; do
        f_pip_conf="/opt/cyops-${dir_name}/.env/pip.conf"
        if [ ! -f $f_pip_conf ]; then
            echo "The $f_pip_conf not found".
            return
        fi

        # Install from offline repo and not from other index-urls such as pypi.org, repo.fortisoar.fortinet.com
        sed -i "s/${s_extra_index_url}/${s_index_url}/g" $f_pip_conf
        sed -i "s/$s_product_yum_server_old/$custom_yum_url/g" $f_pip_conf
        if [ $? -ne 0 ]; then
            echo "warning: Failed to update the ${f_pip_conf} file."
        fi

        #
        # Add trusted-host as default; installation directly preform from trusted-host and not from external URL.
        # It save installation time.
        #
        echo "trusted-host=$custom_yum_url" >>$f_pip_conf
        if [ $? -ne 0 ]; then
            echo "warning: Failed to update the ${f_pip_conf} file."
        fi
    done
}

#
# The install-fortisoar.sh script abort installation while installing \
# the required package if repo.fortisoar.fortinet.com URL is not reachable.
# Need to handle this condition and display the proper message before exit the script.
# This validate_yum_repo () function validate the connectivity of repo.fortisoar.fortinet.com.
# If connectivity fails, then exit the script.
#
validate_yum_repo() {
    if [ ! -z $custom_yum_url ]; then
        #
        # The custom_yum_url variable export before run the script.
        # The s_url variable value validate in the validate_yum_repo function.
        #
        s_product_yum_server=$custom_yum_url
    fi
    echo "Validating the $s_product_yum_server address"
    local i_status
    i_status=$(curl $flag_ignore_ssl_check_curl https://$s_product_yum_server | head -n1 | awk '{print $2}')
    #
    # Check if response will not 200 or i_status variable will empty
    # then repo.fortisoar.fortinet.com URL will not reachable.
    #
    if [ -z $i_status ] || [ $i_status -ne 200 ]; then
        echo "Error: Failed to connect the $s_product_yum_server. \nCheck connection for https://$s_product_yum_server and re-run the script."
        echo "OR use the --ignore-ssl-check option to ignore the ssl check."
        echo "Example: \"./$0 --ignore-ssl-check\" or \"sh $0 --ignore-ssl-check\""
        exit 1
    fi
}

#
# Check the connectivity for https://globalupdate.fortinet.net.
# If there is no connectivity for https://globalupdate.fortinet.net, \
# then ask the user to continue the installation or not.
# The connectivity to this URL is required for fetching the license entitlements.
# This function required for enterprise edition only and not for secure-message-exchange.
#
validate_license_url_connection() {
    local i_count=0
    local validate_licence_url="https://globalupdate.fortinet.net"
    local i_conn_output
    i_conn_output=$(curl -Is $validate_licence_url)
    local status="$?"

    # Response 35 is handshake failure. Since this url requires client certificate validation, a handshake failure would mean the site is reachable.
    if [ $status -eq 35 ] || [ $status -eq 52 ] || [ $status -eq 56 ] || [ $status -eq 0 ]; then
        return
    fi

    echo "WARNING: The system does not have connectivity to $validate_licence_url."
    echo "         Connectivity to this address is required for fetching the"
    echo "         license entitlements and product functioning post_install."
    echo "         You must ensure either direct connectivity to this server,"
    echo "         or to a FortiManager instance that connects to the"
    echo "         Global Update Server."

    # Prompt the user only if flag_interactive_install is true
    if [ "$flag_interactive_install" = "true" ]; then
        # Take user input yes or no. Check the max 3 attempt and exit if invalid input and display the message.
        while [ $i_count -le 2 ]; do
            echo "Do you want to proceed with the installation (y/n)? "
            read s_user_input
            if [ ! -z $s_user_input ]; then
                if [[ $s_user_input =~ y|Y|yes|Yes ]]; then
                    echo ""
                    echo "The install script will proceed with the installation as per your input"
                    echo ""
                    break
                elif [[ $s_user_input =~ n|N|no|No ]]; then
                    echo ""
                    echo "The install script will exit as per your input"
                    echo "Check the connection for $validate_licence_url and then re-run the script."
                    my_exit 1
                else
                    echo "You have provided an invalid input. Re-run the script and provide the valid input."
                    my_exit 1
                fi
            fi
            i_count=$(expr $i_count + 1)
        done
        if [ $i_count -gt 2 ]; then
            echo "Error: Maximum retries exceeded."
            echo "The install script will now exit."
            echo "Re-run the script."
            my_exit 1
        fi
    fi
}

add_user_to_wheel_grp() {
    # In case of AWS or azure , need to add $s_logged_in_user to wheel group to allow ssh login
    # OS hardening enables login only for the users in the wheel group
    echo -e "\033[31;5mWarning\033[0m: FosrtiSOAR product will allow ssh login only to the users in the wheel group."
    echo -e "         It is required to add $s_logged_in_user user to the wheel group to"
    echo -e "         prevent SSH login lockout post reboot.\n"
    read -p "Would you like to add the $s_logged_in_user user to the wheel group [y] or exit [n]? " s_user_input
    if [ ! -z $s_user_input ]; then
        if [[ $s_user_input =~ y|Y|yes|Yes ]]; then
            usermod -a -G $s_group_wheel $s_logged_in_user
        elif [[ $s_user_input =~ n|N|no|No ]]; then
            echo "Add $s_logged_in_user to the wheel group to proceed."
            echo "Exiting."
            my_exit 1
        else
            echo "Error: Invalid input."
            echo "       Re-run the script and provide the valid input."
            my_exit 1
        fi
    fi

}

create_user() {
    echo ""
    echo "============="
    echo "Creating user"
    echo "============="
    if ! id $s_user_csadmin; then
        echo "***************************************"
        echo "Adding user $s_user_csadmin"
        echo "***************************************"
        useradd $s_user_csadmin -s /bin/bash
        if [ $? -ne 0 ]; then
            echo "Failed to create user [$s_user_csadmin]"
            my_exit 1
        fi
    fi

    echo $s_password_csadmin | passwd $s_user_csadmin --stdin
    if [ $? -ne 0 ]; then
        echo "Failed to change the password of user [$s_user_csadmin]"
        my_exit 1
    fi

    # Set passwordless sudo.
    echo "$s_user_csadmin         ALL=(ALL)      NOPASSWD: ALL" >>$sudoers

    add_sudoers_for_root

     # Add user to wheel group.
    usermod -a -G $s_group_wheel $s_user_csadmin
}

#
# The report engine 1.2.0 should render far east languages.
# Added the following font packages for installation.
#
install_font_pkgs() {
    local s_font_pkgs=("gnu-free-fonts-common
                      khmeros-fonts-common
                      smc-fonts-common
                      thai-scalable-fonts-common
                      dejavu-sans-mono-fonts
                      dejavu-serif-fonts
                      gnu-free-mono-fonts
                      gnu-free-sans-fonts
                      gnu-free-serif-fonts
                      google-crosextra-caladea-fonts
                      google-crosextra-carlito-fonts
                      google-noto-emoji-fonts
                      jomolhari-fonts
                      khmeros-base-fonts
                      lklug-fonts
                      lohit-assamese-fonts
                      lohit-bengali-fonts
                      lohit-devanagari-fonts
                      lohit-gujarati-fonts
                      lohit-kannada-fonts
                      lohit-malayalam-fonts
                      lohit-marathi-fonts
                      lohit-nepali-fonts
                      lohit-oriya-fonts
                      lohit-punjabi-fonts
                      lohit-tamil-fonts
                      lohit-telugu-fonts
                      madan-fonts
                      open-sans-fonts
                      overpass-fonts
                      paktype-naskh-basic-fonts
                      paratype-pt-sans-fonts
                      sil-abyssinica-fonts
                      sil-nuosu-fonts
                      sil-padauk-fonts
                      smc-meera-fonts
                      stix-fonts
                      thai-scalable-waree-fonts
                      ucs-miscfixed-fonts
                      vlgothic-fonts
                      wqy-microhei-fonts")
    yum install -y $s_font_pkgs
    if [ $? -ne 0 ]; then
        exit 1
    fi
}

# The is_csadmin_user_exist function check that csadmin user exist or not before installation.
# This check added for automation in Jenkins.
is_csadmin_user_exist() {
    # If csadmin user exist and user start installation from root user. So following command is used.
    getent passwd $s_user_csadmin >/dev/null
    if [ $? -eq 0 ]; then
        echo "true"
    else
        echo "false"
    fi
}

update_yum_repositories() {
    if [ "$flag_is_rhel" == "true" ]; then
        # Allow Auto-enabling of subscription manager repositories
        subscription-manager config --rhsm.manage_repos=1

        # yum-config-manager command comes from yum-utils
        yum install -y yum-utils

        # Rockylinux repo is not available in case of Red Hat installation
        yum-config-manager --disable fsr-rockylinux-baseos, fsr-rockylinux-appstream, fsr-rockylinux-extras, fsr-rockylinux-powertools

        # Ensure required repositories are enabled
        yum-config-manager --enable rhel-${i_version_os}-for-x86_64-baseos-rpms, rhel-${i_version_os}-for-x86_64-appstream-rpms, codeready-builder-for-rhel-${i_version_os}-x86_64-rpms
    fi

    if [ "$s_product_type" = "enterprise" ]; then
        # Default nginx getting installed is of lower version
        # Installing from mainline installs latest version which is bundled in fsr-epel-modular repository
        # For this to happen, need to reset and then enable required stream
        dnf module reset -y nginx
        dnf module enable -y nginx:mainline
        dnf module list nginx
    fi
}

#
# The install_prerequisites() function install \
# the pre requisites like add csadmin user and install cyops-repo-update rpm package.
#
install_prerequisites() {
    # Create csadmin user only when it does not exist
    if [ "$flag_is_csadmin_user_exist" = "false" ]; then
        create_user
    fi

    if [[ "$s_hypervisor_type" = "aws" || "$s_hypervisor_type" = "azure" ]];then
        # Add currently logged in user to wheel group
        id -nG $s_logged_in_user | grep -w $s_group_wheel >/dev/null
        if [ $? -ne 0 ];then
            add_user_to_wheel_grp
        fi
    fi

    # We run commands using sudo which ask for tty if requiretty is enabled, hence disable the requiretty.
    sed -i "s/^\(.*requiretty\)$/#\1/" $sudoers

    # Install the cyops-repo-update.
    rpm -ivh --force cyops-repo-update-${s_product_release_version}*.rpm
    if [ ! -z "$fsr_rpm_location" ]; then
        sed -i "s#\$fsr_release_version#$fsr_rpm_location#g" $d_yum_repo/fsr-app.repo
        yum clean all
    fi

    update_yum_repositories

    if [ $flag_custom_yum_url = "true" ]; then
        custom_yum_repo
        update_environment_file
    fi
    update_cyops_release

    install_third_party_dependencies

    configure_chrony

    install_font_pkgs
}

#
# The welcome_echo() function display \
# the welcome message according to enterprise or secure message exchange product type.
#
welcome_echo() {
    local s_edition=$1
    local s_version=$2
    echo ""
    echo "========================="
    echo "Installing $s_edition $s_version packages"
    echo "========================="
}

set_install_version_string() {
    if [ ! -z $fsr_rpm_location ]; then
        # Private build installation requires release version and build number
        s_install_version="-${fsr_release_version}-${fsr_build_number}.${emulation_layer}"
    else
        # Installation from regular location
        if [ ! -z $fsr_release_version ]; then
            s_install_version="-${fsr_release_version}"
            if [ ! -z $fsr_build_number ]; then
                s_install_version="${s_install_version}-${fsr_build_number}.${emulation_layer}"
            fi
            # If only fsr_release_version is provided then resultant cmd will be "yum install cyops-7.0.1", which is valid
            # Providing only fsr_build_number will be ignored
        fi
    fi
}

# The install_enterprise() function install FortiSOAR for enterprise.
install_enterprise() {
    # Need to disable module else pg server wont install
    my_system "yum module disable -y postgresql"
    my_system "yum module list php"
    my_system "yum module reset php -y"
    my_system "yum module enable -y php:$s_php_ver"
    my_system "yum module list php"
    my_system "yum module reset nodejs -y"
    my_system "yum module list nodejs -y"
    my_system "yum module enable -y nodejs:$s_nodejs_ver"

    # callback service installed separately since it can be installed on a separate instance also
    # hence, has no dependency on cyops rpm
    l_pkgs_to_install="cyops$s_install_version"
    for s_pkg_to_install in $l_pkgs_to_install;do
        s_cmd="yum install -y $s_pkg_to_install"
        echo "Running $s_cmd"
        $s_cmd
        if [ $? -ne 0 ]; then
            echo "Error: Failed to run $s_cmd"
            my_exit 1
        fi
    done

    #
    # Fresh-install is done. Now google-chrome-stable RPM is installed/updated which in turns
    # creates the file $d_yum_repo/google-chrome.repo. Delete this file as
    # in air gap environment, connectivity to internet is not there which result
    # in failure while doing YUM calls as it tries to connect to google.
    #
    rm -f $d_yum_repo/google-chrome.repo

    if [ -f "/etc/cron.daily/google-chrome" ]; then
        # The google-chrome-stable pkg installs /etc/cron.daily/google-chrome
        # which keeps recreating the $d_yum_repo/google-chrome.repo file
        # Update /etc/cron.daily/google-chrome to create the .repo in disabled mode
        sed -i 's/enabled=1/enabled=0/g' /etc/cron.daily/google-chrome
    fi
}

# The install_secure_message_exchange() function installs the FortiSOAR secure message exchange.
install_secure_message_exchange() {
    # Install secure-message-exchange
    echo ""
    echo "========================="
    echo "Installing FortiSOAR Secure Message Exchange packages"
    echo "========================="
    local a_secure_pkgs=("cyops-common" "cyops-rabbitmq")
    local i_secure_pkg=0
    local a_secure_missing_pkgs=()
    local i_secure_len=${#a_secure_pkgs[@]}
    local j=0
    for ((i = 0; i < ${i_secure_len}; i++)); do
        yum install -y ${a_secure_pkgs[$i]}$s_install_version
        if [ $? -ne 0 ]; then
            a_secure_missing_pkgs[$j]=${a_secure_pkgs[$i]}
            i_secure_pkg=1
            j=$(expr $j + 1)
        fi
    done

    if [ $i_secure_pkg -eq 0 ]; then
        set_config_vm
    else
        echo "The following packages are not installed:"
        for s_pkg in ${a_secure_missing_pkgs[@]}; do
            echo "$s_pkg"
        done
        my_exit 1
    fi
}

show_deployment_guide_confirmation() {
    # Prompt the user only if flag_interactive_install is true
    if [ "$flag_interactive_install" = "true" ]; then
        while [ $i_count -le 2 ]; do
            echo -e "\nFor more information on recommended sizes and multidisk support, see the $s_help_doc."
            read -p "Do you wish to continue the installation [y/n]? " s_user_input
            if [ ! -z $s_user_input ]; then
                if [[ $s_user_input =~ y|Y|yes|Yes ]]; then
                    break
                elif [[ $s_user_input =~ n|N|no|No ]]; then
                    echo "The script exited. You can re-run the script."
                    my_exit 1
                else
                    echo "You have provided invalid input. You can re-run the script and provide the valid input."
                    my_exit 1
                fi
            fi
            i_count=$(expr $i_count + 1)
        done
        if [ $i_count -gt 2 ]; then
            echo "You have provided invalid input. Maximum retries exceeded. Re-run the script."
            my_exit 1
        fi
    fi
}

#
# The get_edition() function display \
# the user options enterprise and secure-message-exchange for installation.
#
get_edition() {
    clear
    echo "=================="
    echo "FortiSOAR installation"
    echo "=================="
    local re_integer='^[0-9]+$'

    # Prompt the user only if flag_interactive_install is true
    if [ "$flag_interactive_install" = "true" ]; then
        echo "1] Enterprise"
        echo "2] Secure-Message-Exchange"
        read -p "Please choose edition to be installed [1/2]: " i_edition
        if ! [[ $i_edition =~ $re_integer ]]; then
            echo "Please enter either 1 or 2"
            my_exit 1
        fi
        if [ 1 -ne $i_edition -a \
            2 -ne $i_edition ]; then
            echo "Please enter either 1 or 2"
            my_exit 1
        fi
    fi

    i_index=$(expr $i_edition - 1)
    s_product_type="${a_edition[$i_index]}"
}

#
# The set_config_vm() function add EULA and dialogrc files to bash_profile file.
# So that prompt the EULA and configuration wizard at csadmin ssh login.
#
set_config_vm() {
    # Prompt EULA during fresh install
    local profile=$d_home_csadmin/.bash_profile
    local eula=/opt/cyops/scripts/check_eula.sh
    grep "^\s*$eula\s*$" $profile
    if [ $? != 0 ]; then
        echo $eula >>$profile
        if [ $? != 0 ]; then
            echo "Failed to add EULA to FortiSOAR™. Contact Fortinet Customer Success for assistance"
        else
            chmod +x $eula
        fi
    fi

    # Run config vm at csadmin ssh login
    local vm_config_script=/opt/cyops/scripts/config-vm.sh
    grep "^\s*$vm_config_script\s*$" $profile
    if [ $? != 0 ]; then
        # Call vm config script from bash profile
        echo "sudo $vm_config_script" >>$profile
        cp /opt/cyops/scripts/.dialogrc $d_home_csadmin
        if [ $? != 0 ]; then
            echo "Failed to add config wizard trigger entry to FortiSOAR™. Contact Fortinet Customer Success for assistance"
        else
            chmod +x $vm_config_script
        fi
    fi
}

#
# The install_third_party_dependencies() function install
# the require dependencies before installation start.
install_third_party_dependencies() {
    local l_pkgs_required="aide yum-utils chrony policycoreutils-python-utils setroubleshoot-server firewalld"
    if [ $s_product_type != "secure-message-exchange" ]; then
        l_pkgs_required="$l_pkgs_required python3-policycoreutils gcc java-17-openjdk fio ioping"
    fi

    s_cmd="yum install -y $l_pkgs_required"
    echo "Running $s_cmd"
    $s_cmd

    local l_pkgs_not_installed=""
    for s_pkg in $l_pkgs_required; do
        rpm -qi $s_pkg >/dev/null
        if [ $? -ne 0 ]; then
            l_pkgs_not_installed="$l_pkgs_not_installed $s_pkg"
        fi
    done

    if [ "$l_pkgs_not_installed" != "" ]; then
        echo "The following package(s) is not installed -"
        echo "$l_pkgs_not_installed"
        my_exit 1
    fi


}

# The extract_archive() function extract packages and deployment scripts.
extract_archive() {
    # check if tar is already installed
    yum list installed tar &> /dev/null
    if [ $? -ne 0 ]; then
        yum install -y tar 2> /dev/null
        if [ $? -ne 0 ]; then
            echo "Error: Failed to install tar package."
            echo "       Please install tar package manually and re-run the script. "
            my_exit 1
        fi
    fi
    sed "1,${i_bytes_to_skip}d" $script | tar -xzf - 2>/dev/null
    if [ $? -ne 0 ]; then
        echo "Extract archive failed."
        my_exit 1
    fi
}

# The check_sha512sum() verify the payload checksum.
check_sha512sum() {
    if ! command -v sha512sum &>/dev/null; then
        echo "WARNING: Command sha512sum not found"
        return
    fi

    echo "Verifying sha512sum checksum of payload"

    for f in $(echo $file_vars_list); do
        eval s_bundled_sha512=\$${f}_sha512
        eval file=\$$f
        s_actual_sha512=$(sha512sum $file | cut -d" " -f1)
        if [ "$s_bundled_sha512" != "$s_actual_sha512" ]; then
            echo "\$$f failed sha512sum checksum verification."
            my_exit 1
        else
            echo "sha512sum checksum of $file passed."
            echo "Checksum stamped in bin for $file: $s_bundled_sha512"
            echo "Checksum of actually bundled $file: $s_actual_sha512"
        fi
    done
    echo "Finished verifying sha512sum checksum of packages"
}

check_os() {
    echo ""
    echo "-----------------------------------"
    echo "  Operating System Support Check   "
    echo "-----------------------------------"
    flag_is_os_supported="false"
    s_current_operating_system=$(grep "^NAME=" $f_os_release | sed 's/.*="\(.*\)"/\1/g')
    # Loop through the list and grep each value against $s_current_operating_system
    # Break the loop if found
    for ((i = 0; i < ${#l_supported_os_for_install[@]}; i++)); do
        if [ "$s_current_operating_system" = "${l_supported_os_for_install[$i]}" ]; then
            flag_is_os_supported="true"
            break
        fi
    done

    # Exit with error if supported OS not found
    if [ "$flag_is_os_supported" = "false" ]; then
        echo "Error: Operating System found: "
        echo "       \"$s_current_operating_system\""
        echo "       It is not supported for the installation of FortiSOAR $s_product_release_version"
        echo "       Supported operating systems are:"
        for ((i = 0; i < ${#l_supported_os_for_install[@]}; i++)); do
            i_index=$(expr $i + 1)
            echo "           $i_index. ${l_supported_os_for_install[$i]}"
        done
        echo "       Exiting."
        my_exit 1
    fi
    echo "Done"
    echo ""
}

check_is_user_subscribed() {
    # Checking if user is registered and attached subscription.
        subscription-manager refresh
        subscription-manager status >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            echo "Error: This system is not registered with an entitlement server."
            echo "       You can use subscription-manager to register and attach subscription."
            echo "       Exiting. "
            my_exit 1
        fi
}

pre_install_check() {
    check_root

    check_os

    # The validate_yum_repo function validate the connectivity of repo.fortisoar.fortinet.com
    validate_yum_repo

    if [ "$flag_is_rhel" == "true" ]; then
        check_is_user_subscribed
    fi

    if [ ! -z "$fsr_rpm_location" ]; then
        # If its private build installation, then release version and build number is mandatory
        if [ -z "$fsr_release_version" -o -z "$fsr_build_number" ]; then
            echo "Error: Non empty fsr_rpm_location detected which indicates private build installation"
            echo "       Please export fsr_release_version and fsr_build_number and then rerun the installer"
            echo "       Example - export fsr_release_version=7.2.1"
            echo "                 export fsr_build_number=764"
            my_exit 1
        fi
    fi

    if [ ${a_edition[$i_index]} = "enterprise" ]; then
        show_deployment_guide_confirmation
        # Validate the connectivity of globalupdate.fortinet.net URL before enterprise install start.
        validate_license_url_connection
    fi
}

update_cyops_release() {
    echo "product_type=$s_product_type" >$f_cyops_release
    chmod 644 $f_cyops_release
    chattr +i $f_cyops_release
}

pre_install() {
    extract_archive

    check_sha512sum

    welcome_echo $s_product_type $s_product_release_version

    install_prerequisites
}

install() {
    # Update OS pkgs to latest
    s_cmd="yum update -y"
    echo "Running $s_cmd"
    $s_cmd
    if [ $? -ne 0 ]; then
        echo "Error: Failed to run $s_cmd"
        my_exit 1
    fi

    cleanup_repos

    set_install_version_string
    if [ ${a_edition[$i_index]} = "enterprise" ]; then
        install_enterprise
    elif [ ${a_edition[$i_index]} = "secure-message-exchange" ]; then
        install_secure_message_exchange
    fi
}

# -------------------- OS Hardening functions ----------------------------------
update_fstab() {
    s_option_tmp="$1"
    sed -i "s#\($s_mount_point_label\s\{1,\}/[a-zA-Z0-9/]*\s\{1,\}[a-zA-Z0-9]\{1,\}\s\{1,\}\)\([a-zA-Z,]\{1,\}\)\(.*\)#\1$s_option_tmp\3#g" $f_fstab
    # Above regular expression logic explained below
    # Sample line from /etc/fstab
    # /dev/mapper/vgsearch-search /var/lib/elasticsearch/ xfs     nodev,nosuid,noexec        0 0
    # $s_mount_point_label matches with /dev/mapper/vgsearch-search
    # \s\{1,\} matches one or more whitespaces after /dev/mapper/vgsearch-search
    # /[a-zA-Z0-9/]* matches /var/lib/elasticsearch/
    # \s\{1,\} matches one or more whitespaces after /var/lib/elasticsearch/
    # [a-zA-Z0-9]\{1,\} matches xfs
    # \s\{1,\} matches one or more whitespaces after xfs
    # [a-zA-Z,]\{1,\} matches nodev,nosuid,noexec
    # \(.*\) matches all characters after nodev,nosuid,noexec
}

function configure_fstab() {
    echo "Fixing $f_fstab"
    cat <<EOF >>$f_fstab
/tmp 	/var/tmp 	none	bind 	0 0
none	/dev/shm	tmpfs 	nosuid,nodev,noexec 	0 0
EOF

    # Ensure nodev option set on /var, /var/log/, /var/log/audit, /home partition
    # Description:
    # The nodev mount option specifies that the filesystem cannot contain special devices.
    # Since the /var filesystem is not intended to support devices, set this option to ensure that users cannot create a block or character special devices in /var .

    # The noexec mount option specifies that the filesystem cannot contain executable binaries.
    # Since the /var filesystem is only intended for variable files such as logs, set this option to ensure that users cannot run executable binaries from /var .

    # The nosuid mount option specifies that the filesystem cannot contain setuid files.
    # Since the /var filesystem is only intended for variable files such as logs, set this option to ensure that users cannot create setuid files in /var .

    l_partitions="/tmp \
                 /var/tmp \
                 /var \
                 /var/log \
                 /var/log/audit \
                 /home"

    l_options="nodev \
               noexec \
               nosuid"

    l_options_home_additional="usrquota \
                               grpquota"

    # Logic
    # Loop l_partitions
    #    find on which mount point the partition is mounted (s_mount_point_label)
    #    if partition is /home
    #        Loop l_options_home_additional
    #           add option usrquota and grpquota if its not already there
    #    Loop l_options
    #        if partition is /home and option is noexec, skip loop
    #        add option to the mp entry in /etc/fstab if it is not already there

    # Loop l_partitions
    for s_partition in $l_partitions; do
        # Find on which mount point the partition is mounted (s_mount_point_label)
        s_mount_point_label=$(df -k $s_partition | sed 1d | awk '{print $1}')

        s_mount_point=$(grep "$s_mount_point_label" $f_fstab | awk '{print $2}')
        if [ "$s_mount_point" = "/" ]; then
            # Services fail to start if noexec, nosuid, nodev options are added to /
            continue
        fi

        # usrquota and grpquota need to be added to the /home partition only
        if [ "$s_partition" = "/home" ]; then
            # Loop l_options_home_additional
            for s_option_home_additional in $l_options_home_additional; do
                s_options_home=$(grep "$s_mount_point_label" $f_fstab | awk '{print $4}')
                echo $s_options_home | grep -q $s_option_home_additional
                if [ $? -eq 1 ]; then
                    # Add the option if its not already there
                    s_options_home_new="$s_options_home,$s_option_home_additional"
                    update_fstab "$s_options_home_new"
                fi
            done
        fi

        # Loop l_options
        for s_option in $l_options; do
            # If partition is /home and option is noexec, skip loop
            # CIS scanner does not suggest to add noexec to the /home partition hence need to skip it
            if [ "$s_partition" = "/home" -a \
                "$s_option" = "noexec" ]; then
                continue
            fi

            s_options=$(grep "$s_mount_point_label" $f_fstab | awk '{print $4}')
            echo $s_options | grep -q $s_option
            if [ $? -eq 1 ]; then
                # Add the option to the $s_mount_point_label entry in /etc/fstab, if the option is not already there
                s_options_new="$s_options,$s_option"
                update_fstab "$s_options_new"
            fi
        done
    done
}

function fix_modprob() {
    echo "Disable mounting of unneeded filesystems"
    f_modprob_d_cis_conf="/etc/modprobe.d/cis.conf"
    l_unneeded_os="cramfs
				   freevxfs
				   jffs2
				   hfs
				   hfsplus
				   squashfs
				   udf
				   vfat
				   dccp
				   sctp
				   rds
				   tipc
				   usb-storage"

    # Get list of filesystems mentioned in /etc/fstab
    # Need to remove commented and empty lines
    l_file_systems_in_fstab=$(cat $f_fstab | sed 's/^\s*#.*//g' | sed '/^\s*$/d' | awk '{print $3}' | sort | uniq)

    for s_unneeded_os in $l_unneeded_os; do
        # Cannot blacklist a filesystem if its mentioned in the /etc/fstab
        echo $l_file_systems_in_fstab | grep --quiet --fixed-strings $s_unneeded_os
        if [ $? -ne 0 ]; then
            echo "install $s_unneeded_os /bin/false" >>$f_modprob_d_cis_conf
            echo "blacklist $s_unneeded_os" >>$f_modprob_d_cis_conf
        fi
    done
}

function import_gpg_key() {
    echo "Ensuring GPG correct."
    rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-rockyofficial
}

function disable_auto_mounting() {
    echo "Disabling Auto-mounting of disks."
    # Disable automounting of removable media
    cat <<EOF >>/etc/dconf/db/local.d/00-media-automount

[org/gnome/desktop/media-handling]

automount=false

automount-open=false

EOF
}

function ensure_grub_perms() {
    f_grub_conf="/boot/grub2/grub.cfg"
    if [ -f "$f_grub_conf" ]; then
        echo "Ensuring gurb file perms are correct."
        chown root:root $f_grub_conf
        chmod og-rwx $f_grub_conf
    fi
}
function restrict_core_dumps() {
    echo "Restrict Core Dumps."
    cat <<EOF >/etc/security/limits.d/01-cis.conf
*	hard	core 	0
EOF

}

function set_message_perms() {
    echo "Setting permissions on banner files"
    chown root:root /etc/motd
    chmod 644 /etc/motd
    chown root:root /etc/issue
    chmod 644 /etc/issue
    chown root:root /etc/issue.net
    chmod 644 /etc/issue.net
}

function fix_ntp() {
    echo "Fixing NTP for CIS"
    cat <<EOF >>/etc/ntp.conf
restrict -4 default kod nomodify notrap nopeer noquery
restrict -6 default kod nomodify notrap nopeer noquery
EOF
}

function disable_unneeded_services() {
    echo "Disabling unneeded services"
    l_unneeded_services="nfs \
                         rpcbind \
                         rsyncd \
                         autofs"
    for s_unneeded_service in $l_unneeded_services; do
        systemctl list-units --full -all | grep --fixed-strings --quiet "$s_unneeded_service.service"
        if [ $? -eq 0 ]; then
            systemctl disable $s_unneeded_service
        fi
    done

    l_mask_services="nfs-server \
                         rpcbind \
                         rpcbind.socket \
                         nftables"
    for s_mask_service in $l_mask_services; do
        systemctl list-units --full -all | grep --fixed-strings --quiet "$s_mask_service.service"
        if [ $? -eq 0 ]; then
            systemctl --now mask $s_mask_service
        fi
    done
}

function fix_sys_ctl() {
    echo "Creating cis sysctl conf file."

    cat <<EOF >/etc/sysctl.d/cis.conf
fs.suid_dumpable = 0
kernel.randomize_va_space = 2
net.ipv4.ip_forward = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.default.accept_source_route = 0
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.default.secure_redirects = 0
net.ipv4.conf.all.log_martians = 1
net.ipv4.conf.default.log_martians = 1
net.ipv4.icmp_echo_ignore_broadcasts = 1
net.ipv4.icmp_ignore_bogus_error_responses = 1
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1
net.ipv4.tcp_syncookies = 1
net.ipv6.conf.all.accept_ra = 0
net.ipv6.conf.default.accept_ra = 0
net.ipv6.conf.all.accept_redirect = 0
net.ipv6.conf.default.accept_redirect = 0
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv4.route.flush = 1
EOF

}

function create_audit_rules() {
    echo "Creating CIS audit rules"
    cat <<EOF >>/etc/audit/rules.d/audit-cis.rules
-a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time-change
-a always,exit -F arch=b32 -S adjtimex -S settimeofday -S stime -k time-change
-a always,exit -F arch=b64 -S clock_settime -k time-change
-a always,exit -F arch=b32 -S clock_settime -k time-change
-w /etc/localtime -p wa -k time-change
-w /etc/group -p wa -k identity
-w /etc/passwd -p wa -k identity
-w /etc/gshadow -p wa -k identity
-w /etc/shadow -p wa -k identity
-w /etc/security/opasswd -p wa -k identity

-a always,exit -F arch=b64 -S sethostname -S setdomainname -k system-locale
-a always,exit -F arch=b32 -S sethostname -S setdomainname -k system-locale
-w /etc/issue -p wa -k system-locale
-w /etc/issue.net -p wa -k system-locale
-w /etc/hosts -p wa -k system-locale
-w /etc/sysconfig/network -p wa -k system-locale

-w /etc/selinux/ -p wa -k MAC-policy

-w /var/log/lastlog -p wa -k logins
-w /var/run/faillock/ -p wa -k logins

-w /var/run/utmp -p wa -k session
-w /var/log/wtmp -p wa -k session
-w /var/log/btmp -p wa -k session
#
-a always,exit -F arch=b64 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
-a always,exit -F arch=b32 -S chmod -S fchmod -S fchmodat -F auid>=1000 -F auid!=4294967295 -k perm_mod
-a always,exit -F arch=b64 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
-a always,exit -F arch=b32 -S chown -S fchown -S fchownat -S lchown -F auid>=1000 -F auid!=4294967295 -k perm_mod
-a always,exit -F arch=b64 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
-a always,exit -F arch=b32 -S setxattr -S lsetxattr -S fsetxattr -S removexattr -S lremovexattr -S fremovexattr -F auid>=1000 -F auid!=4294967295 -k perm_mod
#
-a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
-a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=4294967295 -k access
-a always,exit -F arch=b64 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access
-a always,exit -F arch=b32 -S creat -S open -S openat -S truncate -S ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=4294967295 -k access

-a always,exit -F path=/usr/bin/wall -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/write -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/chage -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/chfn -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/chsh -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/su -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/pkexec -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/ssh-agent -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/sbin/pam_timestamp_check -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/sbin/netreport -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/sbin/usernetctl -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/sbin/postdrop -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/sbin/postqueue -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/lib/polkit-1/polkit-agent-helper-1 -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/lib64/dbus-1/dbus-daemon-launch-helper -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/libexec/utempter/utempter -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged
-a always,exit -F path=/usr/libexec/openssh/ssh-keysign -F perm=x -F auid>=1000 -F auid!=4294967295 -k privileged

-a always,exit -F arch=b64 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts
-a always,exit -F arch=b32 -S mount -F auid>=1000 -F auid!=4294967295 -k mounts

-a always,exit -F arch=b64 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete
-a always,exit -F arch=b32 -S unlink -S unlinkat -S rename -S renameat -F auid>=1000 -F auid!=4294967295 -k delete

-w /etc/sudoers -p wa -k scope
-w /var/log/sudo.log -p wa -k actions

-w /sbin/insmod -p x -k modules
-w /sbin/rmmod -p x -k modules
-w /sbin/modprobe -p x -k modules
-a always,exit -F arch=b64 -S init_module -S delete_module -k modules

EOF
}

function config_rsyslogd() {
    echo "Configure rsyslog for cis"
    cat <<EOF >/etc/rsyslog.d/cid.conf
*.emerg				 		:omusrmsg:*
mail.*						-/var/log/mail
mail.info					-/var/log/mail.info
mail.warning				-/var/log/mail.warn
mail.err					/var/log/mail.err
news.crit					-/var/log/news/news.crit
news.err					-/var/log/news/news.err
news.notice					-/var/log/news/news.notice
*.=warning;*.=err			-/var/log/warn
*.crit						/var/log/warn
local0,local1.*				-/var/log/localmessages
local2,local3.*				-/var/log/localmessages
local4,local5.*				-/var/log/localmessages
local6,local7.*				-/var/log/localmessages

\$FileCreateMode 0640

EOF
}

insert_or_replace() {
    local s_key=$1
    local s_value=$2

    if [ -z "$s_value" ]; then
        # Optional entry
        return 0
    fi

    grep -q $s_key $f_sshd_config
    if [ $? -eq 0 ]; then
        sed -i "s/$s_key \(.*\)/$s_key $s_value/g" $f_sshd_config
    else
        echo "" >>$f_sshd_config
        echo "$s_key $s_value" >>$f_sshd_config
    fi
}

function fix_sshd() {
    echo "Fixing sshd config file"
    sed -i "s/\#MaxStartups.*/MaxStartups 10:30:60/" ${f_sshd_config}
    sed -i "s/\#Protocol/Protocol/" ${f_sshd_config}
    sed -i "s/\#LogLevel/LogLevel/" ${f_sshd_config}
    sed -i "s/X11Forwarding yes/X11Forwarding no/" ${f_sshd_config}
    sed -i "s/\#MaxAuthTries 6/MaxAuthTries 4/" ${f_sshd_config}
    sed -i "s/\#IgnoreRhosts yes/IgnoreRhosts yes/" ${f_sshd_config}
    sed -i "s/\#HostbasedAuthentication no/HostbasedAuthentication no/" ${f_sshd_config}
    sed -i "s/^#*PermitRootLogin \(yes\|no\)/PermitRootLogin no/g" ${f_sshd_config}
    sed -i "s/\#PermitEmptyPasswords no/PermitEmptyPasswords no/" ${f_sshd_config}
    sed -i "s/\#PermitUserEnvironment no/PermitUserEnvironment no/" ${f_sshd_config}

    local line_num=$(grep -n "^\# Ciphers and keying" ${f_sshd_config} | cut -d: -f1)
    sed -i "${line_num} a Ciphers aes128-ctr,aes192-ctr,aes256-ctr" ${f_sshd_config}

    sed -i "s/\#ClientAliveInterval 0/ClientAliveInterval 300/" ${f_sshd_config}
    sed -i "s/\#ClientAliveCountMax 3/ClientAliveCountMax 0/" ${f_sshd_config}
    sed -i "s/\#LoginGraceTime 2m/LoginGraceTime 60/" ${f_sshd_config}
    sed -i "s/\#Banner none/Banner \/etc\/issue\.net/" ${f_sshd_config}
    echo "MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-512,hmac-sha2-256,umac-128@openssh.com" >>${f_sshd_config}
    echo "AllowGroups $s_group_wheel" >>${f_sshd_config}

    # 1. Cipher Block Chaining (CBC) encryption may allow an attacker to recover the plaintext message from the ciphertext
    #   So need to remove CBC config setting
    # 2. The remote SSH server is configured to allow key exchange algorithms which are considered weak.
    #   This is based on the IETF draft document Key Exchange (KEX) Method Updates and Recommendations for Secure Shell (SSH) draft-ietf-curdle-ssh-kex-sha2-20.
    # Section 4 lists guidance on key exchange algorithms that SHOULD NOT and MUST NOT be enabled. This includes:
    # diffie-hellman-group-exchange-sha1
    # diffie-hellman-group1-sha1
    # gss-gex-sha1-*
    # gss-group1-sha1-*
    # gss-group14-sha1-*
    # rsa1024-sha1

    l_vulnerable_ciphertext_and_algorithms="aes128-cbc \
    aes256-cbc \
    diffie-hellman-group-exchange-sha1 \
    diffie-hellman-group1-sha1 \
    gss-gex-sha1- \
    gss-group1-sha1- \
    gss-group14-sha1- \
    rsa1024-sha1
    "

    for f_ssh_config in $l_ssh_config_files; do
        for s_vulnerable_ciphertext_and_algorithms in $l_vulnerable_ciphertext_and_algorithms; do
            sed -i --follow-symlinks "s/\(,|:\)\?$s_vulnerable_ciphertext_and_algorithms//g" "$d_cypto_policies_back_ends/$f_ssh_config"
        done
    done

    l_kex_algorithms="
    ecdh-sha2-nistp256
    ecdh-sha2-nistp384
    ecdh-sha2-nistp521
    diffie-hellman-group14-sha1
    diffie-hellman-group-exchange-sha256
    "

    # Convert the multi-line list into single-line comma separated list
    s_kex_algorithms=$(echo $l_kex_algorithms | tr ' ' ,)
    insert_or_replace KexAlgorithms "$s_kex_algorithms"

    chown root:root ${f_sshd_config}
    chmod og-rwx ${f_sshd_config}
}

function fix_bash() {
    echo "Fixing bashrc stuff."
    bashrc='/etc/bashrc'
    #first umask cmd sets it for users, second umask cmd sets it for system reserved uids
    #we want to alter the first one
    line_num=$(grep -n "^[[:space:]]*umask" ${bashrc} | head -1 | cut -d: -f1)
    sed -i ${line_num}s/002/027/ ${bashrc}
    cat <<EOF >>/etc/profile.d/cis.sh
#!/bin/bash

umask 027
EOF

}

function fix_random_perms() {
    echo "Fixing random file perms"
    chmod 644 /etc/passwd
    chown root:root /etc/passwd

    chmod 000 /etc/shadow
    chown root:root /etc/shadow

    chmod 000 /etc/gshadow
    chown root:root /etc/gshadow

    chmod 644 /etc/group
    chown root:root /etc/group

    chown root:root $f_sshd_config
    chmod og-rwx $f_sshd_config

    chown root:root /etc/passwd-
    chmod 600 /etc/passwd-

    chown root:root /etc/group-
    chmod 600 /etc/group-
}

fs_integrity() {
    echo "Adding filesystem integrity check in crontab"
    # Ensure filesystem integrity is regularly checked
    crontab -l | grep "/usr/sbin/aide --check" >/dev/null
    if [ 1 = $? ]; then
        f_file=tmp_file
        crontab -l >$f_file
        echo '0 5 * * * /usr/sbin/aide --check' >>$f_file
        crontab $f_file
        rm -f $f_file
    fi
}

bootloader_perms() {
    echo "Setting bootloader config files permission and ownership"
    # Ensure permissions on bootloader config are configured - grub.cfg
    f_file=/boot/grub2/grub.cfg
    if [ -f "$f_file" ]; then
        chown root:root $f_file
        chmod og-rwx $f_file
    fi

    # Ensure permissions on bootloader config are configured - user.cfg
    f_file=/boot/grub2/user.cfg
    if [ -f "$f_file" ]; then
        chown root:root $f_file
        chmod og-rwx $f_file
    fi
}

set_sticky_bit() {
    echo "Setting sticky bit on all world-writable directories"
    # Ensure sticky bit is set on all world-writable directories
    df --local -P | awk {'if (NR!=1) print $6'} | xargs -I '{}' find '{}' -xdev -type d -perm -0002 2>/dev/null | xargs chmod a+t
}

disable_ipv6() {
    echo "Disabling IPv6"
    # Ensure IPv6 is disabled
    f_file=/etc/sysctl.conf
    grep "net.ipv6.conf.all.disable_ipv6" $f_file >/dev/null
    if [ 1 = $? ]; then
        echo "net.ipv6.conf.all.disable_ipv6 = 1" >>$f_file
    fi

    grep "net.ipv6.conf.default.disable_ipv6" $f_file >/dev/null
    if [ 1 = $? ]; then
        echo "net.ipv6.conf.default.disable_ipv6 = 1" >>$f_file
    fi

    grep "net.ipv6.conf.lo.disable_ipv6" $f_file >/dev/null
    if [ 1 = $? ]; then
        echo "net.ipv6.conf.lo.disable_ipv6 = 1" >>$f_file
    fi

    grep "net.ipv6.conf.all.accept_redirects" $f_file >/dev/null
    if [ 1 = $? ]; then
        echo "net.ipv6.conf.all.accept_redirects = 0" >>$f_file
    fi

    grep "net.ipv6.conf.default.accept_redirects" $f_file >/dev/null
    if [ 1 = $? ]; then
        echo "net.ipv6.conf.default.accept_redirects = 0" >>$f_file
    fi

    grep "net.ipv6.route.flush" $f_file >/dev/null
    if [ 1 = $? ]; then
        echo "net.ipv6.route.flush = 1" >>$f_file
    fi

    sudo sysctl -p >/dev/null
}

disable_unwanted_kernel_modules() {
    echo "Disabling loading of unwanted kernel modules"
    # Do not load unwanted kernel modules
    f_blacklist=/etc/modprobe.d/cyops-blacklist.conf

    rm -f $f_blacklist
    a_kernel_mods="parport_pc \
                   cdrom \
                   floppy \
                   intel_powerclamp \
                   pcspkr \
                   ppdev"
    for s_kernel_mod in $a_kernel_mods; do
        # Blacklist the kernel module so that next time it is not loaded
        echo "blacklist $s_kernel_mod" >>$f_blacklist

        lsmod | grep --quiet $s_kernel_mod
        if [ $? -eq 0 ]; then
            # Unload the kernel module if its loaded
            modprobe -r $s_kernel_mod
        fi
    done
    chmod 644 $f_blacklist
}

set_default_file_perm() {
    echo "Ensuring rsyslog default file permissions configured"
    # Ensure rsyslog default file permissions configured
    grep \$FileCreateMode /etc/rsyslog.conf >/dev/null
    if [ 1 = $? ]; then
        echo "\$FileCreateMode 0640" >>/etc/rsyslog.conf
    fi
}

fix_logfiles_perms() {
    echo "Ensuring permissions on all logfiles are configured"
    # Ensure permissions on all logfiles are configured
    find /var/log -type f -perm /g+wx,o+rwx -exec chmod --changes g-wx,o-rwx "{}" +
}

fix_cron() {
    # Description:
    # If cron is installed in the system, configure /etc/cron.allow to allow specific users to use these services. If /etc/cron.allow does not exist, then /etc/cron.deny is checked. Any user not specifically defined in those files is allowed to use cron. By removing the file, only users in /etc/cron.allow are allowed to use cron.

    # Note: Even though a given user is not listed in cron.allow , cron jobs can still be run as that user. The cron.allow file only controls administrative access to the crontab command for scheduling and modifying cron jobs.

    # On many systems, only the system administrator is authorized to schedule cron jobs. Using the cron.allow file to control who can run cron jobs enforces this policy. It is easier to manage an allow list than a deny list. In a deny list, you could potentially add a user ID to the system and forget to add it to the deny files.
    f_cron_deny="/etc/cron.deny"
    if [ -e "$f_cron_deny" ]; then
        rm -f $f_cron_deny
    fi

    f_cron_allow="/etc/cron.allow"
    if [ ! -e "$f_cron_allow" ]; then
        touch $f_cron_allow
    fi
    chown root:root $f_cron_allow
    chmod u-x,go-rwx $f_cron_allow

    echo "Fixing cron file permissions and ownership"
    chown root:root /etc/crontab
    chmod og-rwx /etc/crontab
    chown root:root /etc/cron.hourly
    chmod og-rwx /etc/cron.hourly
    chown root:root /etc/cron.daily
    chmod og-rwx /etc/cron.daily
    chown root:root /etc/cron.weekly
    chmod og-rwx /etc/cron.weekly
    chown root:root /etc/cron.monthly
    chmod og-rwx /etc/cron.monthly
    chown root:root /etc/cron.d
    chmod og-rwx /etc/cron.d
}

configure_chrony() {
    f_chronyd="/etc/sysconfig/chronyd"
    echo "Ensuring chrony is configured"
    grep "OPTIONS=.*-u chrony.*" $f_chronyd >/dev/null
    if [ 1 = $? ]; then
        sed -i 's/\(OPTIONS=.*\)\("\)$/\1 -u chrony"/g' $f_chronyd
    fi

    echo "
# Picking up one server from each zone
# Ref: https://www.ntppool.org/zone/@
server 0.north-america.pool.ntp.org
server 0.africa.pool.ntp.org
server 0.asia.pool.ntp.org
server 0.europe.pool.ntp.org
server 0.oceania.pool.ntp.org
server 0.south-america.pool.ntp.org" >>/etc/chrony.conf

    # The chrony installation code is already added in the install_third_party_dependencies function.
    # The following command enable the chrony service after reboot the instance.
    #
    systemctl enable chronyd
    if [ $? -ne 0 ]; then
        # If failed to enable the chrony service then return the code.
        echo "Failed to enable chrony service"
        return
    fi
    # Need to start chrony service after configured the chrony.
    systemctl start chronyd
    systemctl start firewalld
    firewall-cmd --permanent --zone=public --add-service=ntp --permanent >/dev/null
}

set_sys_acc_non_login() {
    echo "Ensuring system accounts are non-login"
    for user in $(awk -F: '($3 < 1000) {print $1 }' /etc/passwd); do
        if [ $user != 'root' ] &&
            [ $user != "$s_user_csadmin" ] &&
            [ $user != 'sync' ] &&
            [ $user != 'shutdown' ] &&
            [ $user != 'postgres' ] &&
            [ $user != 'halt' ]; then
            usermod -s /sbin/nologin $user
        fi
    done
}

fix_su() {
    echo "Ensuring access to the su command is restricted"
    grep "^\s*auth\s*required\s*pam_wheel.so\s*use_uid" /etc/pam.d/su >/dev/null
    if [ 1 = $? ]; then
        echo "auth required pam_wheel.so use_uid" >>/etc/pam.d/su
    fi

    grep "^$s_group_wheel.*:.*root.*" /etc/group >/dev/null
    if [ 1 = $? ]; then
        sed -i "s/\(^$s_group_wheel.*:.*\)/\1,root/g" /etc/group
    fi
}

configure_journald() {
    # Description:
    # The journald system includes the capability of compressing overly large files to avoid filling up the system with logs or making the logs unmanageably large.

    # Uncompressed large files may unexpectedly fill a filesystem leading to resource unavailability. Compressing logs prior to write can prevent sudden, unexpected filesystem impacts.
    f_journald_conf="/etc/systemd/journald.conf"
    sed -i "s/#Compress=yes/Compress=yes/g" $f_journald_conf
    sed -i "s/#Storage=auto/Storage=persistent/g" $f_journald_conf
    systemctl list-units --full -all | grep --fixed-strings --quiet "systemd-journal-upload.service"
    if [ $? -eq 0 ]; then
        systemctl restart systemd-journal-upload
    fi
}

fix_sudo() {
    # Description:
    # sudo can be configured to run only from a pseudo terminal ( pseudo-pty ).

    # Attackers can run a malicious program using sudo which would fork a background process that remains even when the main program has finished executing.
    f_sudoers="/etc/sudoers"
    echo "Defaults use_pty" >>$f_sudoers
    echo "Defaults logfile=\"/var/log/sudo.log\"" >>$f_sudoers
}

configure_authentication() {
    # Description:
    # Lock out users after n unsuccessful consecutive login attempts.

    # deny=<n> - Number of attempts before the account is locked
    # unlock_time=<n> - Time in seconds before the account is unlocked
    # Note: The maximum configurable value for unlock_time is 604800

    # Locking out user IDs after n unsuccessful consecutive login attempts mitigates brute force password attacks against your systems.
    f_faillock_conf="/etc/security/faillock.conf"
    sed -i "s/# deny =.*/deny = 3/g" $f_faillock_conf
    sed -i "s/# unlock_time =.*/unlock_time = 600/g" $f_faillock_conf
}

configure_aide() {
    echo "Configuring AIDE"
    aide --init
    mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
}

remove_unwanted_pkgs() {
    echo "Removing unwanted packages"
    yum remove -y telnet >/dev/null 2>&1
}

os_hardening() {
    echo "----------------------"
    echo " OS hardening changes"
    echo "----------------------"
    configure_fstab
    fix_modprob
    import_gpg_key
    disable_auto_mounting
    restrict_core_dumps
    fix_ntp
    disable_unneeded_services
    fix_sys_ctl
    create_audit_rules
    config_rsyslogd
    fix_sshd
    fix_bash
    set_message_perms
    fix_random_perms
    fs_integrity
    bootloader_perms
    set_sticky_bit
    disable_ipv6
    set_default_file_perm
    fix_logfiles_perms
    disable_unwanted_kernel_modules
    fix_cron
    set_sys_acc_non_login
    fix_su
    configure_journald
    fix_sudo
    configure_authentication
    remove_unwanted_pkgs
    configure_aide
    echo "----------------------------"
    echo " OS hardening changes: Done"
    echo "----------------------------"
}
# --------------------- OS Hardening functions end -----------------------------

# Core dump configuration settings for cyops
configure_core_dump() {
    f_cyops_core_dump_conf="/etc/sysctl.d/cyops-core-dump.conf"
    f_cyops_core_dump_limits_conf="/etc/security/limits.d/cyops-core-dump-limits.conf"
    f_system_conf="/etc/systemd/system.conf"
    f_sysconfig_init="/etc/sysconfig/init"
    d_core_dump="/var/log/cyops/coredump"

    # Naming of core dump files as per -
    # http://man7.org/linux/man-pages/man5/core.5.html
    f_core_dump="core-%E-sig%s-user%u-group%g-pid%p-time%t"

    # Set core dump location and file name
    mkdir -p $d_core_dump
    chmod 777 $d_core_dump
    echo "kernel.core_pattern=$d_core_dump/$f_core_dump" >$f_cyops_core_dump_conf

    # By setting core_uses_pid to 1, the coredump filename becomes <filename>.PID
    echo "kernel.core_uses_pid = 1" >>$f_cyops_core_dump_conf

    # core can be dumped from a setuid program
    echo "fs.suid_dumpable = 2" >>$f_cyops_core_dump_conf

    # Set hard and soft limits for all users
    echo "* hard core unlimited" >$f_cyops_core_dump_limits_conf
    echo "* soft core unlimited" >>$f_cyops_core_dump_limits_conf

    # Set default core limit
    echo "DefaultLimitCORE=infinity" >>$f_system_conf

    # Added to enable coredumps for daemon processes
    echo "DAEMON_COREFILE_LIMIT='unlimited'" >>$f_sysconfig_init

    systemctl daemon-reexec
}

configure_postfix() {
    # Change protocols
    echo "===> Configuring postfix"
    sed -i "s/inet_protocols = all/inet_protocols = ipv4/g" /etc/postfix/main.cf

    echo "===> Starting postfix"
    systemctl enable postfix
    systemctl restart postfix
}

cleanup_repos() {
    # Want the system point to FSR repos only
    rm -f $d_yum_repo/redhat-*.repo
    rm -f $d_yum_repo/Rocky-*.repo
    rm -f $d_yum_repo/google-chrome.repo
    yum clean all
}

expire_csadmin_password() {
    # We want to force user to change the password for 'csadmin'
    # on first login on FortiCloud or on enterprise.
    # Hence expire the password for user 'csadmin'
    echo "Expiring the password for OS user [$s_user_csadmin]"
    passwd --expire $s_user_csadmin
}

cleanup() {
    cleanup_repos

    if [ "$flag_expire_csadmin_password" = "true" ];then
        expire_csadmin_password
    fi
}

install_sp_soar_framework() {
    local f_get_pg_pwd_transact="/opt/cyops/adm/transaction.sh"
    if [ $s_product_type != "enterprise" ]; then
        return
    fi
    #
    # During SP installation if user login to the instance then config wizard starts \
    # to avoid such situation .postinstall_tasks_inprogress file create before that SP installation and
    # the config-vm.sh file will not start the configuration wizard.
    #
    local f_sp_installation=".postinstall_tasks_inprogress"
    touch $d_home_csadmin/$f_sp_installation
    source /etc/environment
    source $f_get_pg_pwd_transact
    #
    # Add self node entry in cluster table. This is required as during SP installation, crudhub
    # calls DAS API to get the cluster nodes and performs further operation based on it.
    #
    local node_id=$(csadm license --get-device-uuid)
    local hostname=$(hostname)
    PGPASSWORD=${s_pg_pwd} psql -U cyberpgsql -d das -c "insert into cluster values ('$node_id', '$hostname', 'active', 'primary', 'primary server');"

    #
    # Need to restart all services, if we don't we get below error:
    # 'Requested resource not found.'
    #
    csadm services --restart

    #
    # During SP install, it requests for workflow global variable. Since license is not installed,
    # workflow service keep on retrying for license for 300 secs. Need to wait for 300 sec for
    # workflow service to come up. Adding 320 considering 20 secs as buffer. Logic can be further
    # enhance by checking if workflow is up.
    #
    echo "Awaiting 320 seconds"
    sleep 320

    echo "Fetching content hub records from repo."
    sudo -u nginx php /opt/cyops-api/bin/console fortisoar:contenthub:sync --force
    if [ $? -eq 0 ]; then
        echo "Installing the SOARFramework Solution Pack"
        /opt/cyops/scripts/api_caller.py \
            --endpoint "https://localhost/api/3/solutionpacks/install" \
            --method POST \
            --payload '{"name":"sOARFramework","version":"2.1.0"}' \
            --silent \
            --monitor-sp
        local ret_code=$?
        # connector installation comes back async. wait before clearing cluster table
        sleep 320

        echo "Cleaning up not installed Solution Packs."
        PGPASSWORD=${s_pg_pwd} psql -U cyberpgsql -d venom -c "delete from solutionpacks where installed=false;"

        if [ $ret_code -ne 0 ]; then
            echo "Failed to install SOARFramework solution pack"
        fi

    else
        echo "Warning: Failed to Fetch content hub records from the repository"
        echo "         Skipping SOARFramework solution pack installation"
    fi
    # Delete temporary added self node entry in cluster table
    PGPASSWORD=${s_pg_pwd} psql -U cyberpgsql -d das -c "truncate cluster;"
    rm -f $d_home_csadmin/$f_sp_installation
}

# The system_reboot() function checks if instance required to reboot or not.
system_reboot() {
    # The needs-restarting command only report whether a
    # full reboot is required (returns 1) or not (returns 0).
    needs-restarting -r >/dev/null
    if [ $? -eq 1 ]; then
        echo "It is recommended to reboot the instance to ensure that your system benefits from updates."
    fi
    # If there is no update in the system package, then above exit 0 will exit the script.
}

update_banner(){
    f_motd="/etc/motd"
    s_pkg_cyops="cyops-common"
    s_platform_release=$(sed 's/^.\+ release \([.0-9]\+\).*/\1/' /etc/redhat-release)
    s_release_version=$(rpm -q $s_pkg_cyops | cut -d'-' -f3)
    i_installed_cyops_build=$(rpm -q $s_pkg_cyops | cut -d'-' -f4 | cut -d'.' -f1)
    cat <<EOF >$f_motd
----------------------------------------------------------------
Rockylinux Version: $s_platform_release
FortiSOAR Version: $s_release_version-$i_installed_cyops_build
Installed on: $(date +%Y-%m-%d)
----------------------------------------------------------------
EOF
}

show_message() {
    # Blinking message to catch the attention of the user
    echo ""
    echo "Install process is now complete."
    echo ""
    echo "-----"
    echo "Note:"
    echo "-----"
    echo "1. You may check the RPM upgrade logs in the directory /var/log/cyops/install."
    echo "   In case there are any failures in the logs, contact support."
    echo "2. Direct SSH login as root user is disabled."
    echo "   To be able to login as root user, login as $s_user_csadmin user and then run sudo su"

    # Check and prompt the user for system reboot if flag_interactive_install is true
    # If flag_interactive_install is false, it may be an automated installation
    if [ "$flag_interactive_install" = "true" ]; then
        echo ""
        system_reboot
    fi
}

post_install() {
    configure_core_dump

    # postfix configuration is required only on enterprise
    if [ "$s_product_type" = "enterprise" ]; then
        configure_postfix
    fi

    if [ $flag_custom_yum_url = "true" ]; then
        update_pip_conf
        grep -wq $s_product_yum_server_old $f_etc_environment
        if [ $? -eq 0 ]; then
            # Replace repo.fortisoar.fortinet.com if offline yum repo in the /etc/environment file.
            sed -i "s/$s_product_yum_server_old/$custom_yum_url/g" $f_etc_environment
            return_status $f_etc_environment $?
        fi
    fi

    if [ "$skip_install_sfsp" = "false" ]; then
        install_sp_soar_framework
    fi

    non_csadmin_user_login

    update_banner

    # -----------------------------------------------------------------------------
    # IMPORTANT: DO NOT PUT ANY CONFIGURATION CODE AFTER OS HARDENING FUNCTION CALL
    # -----------------------------------------------------------------------------
    os_hardening

    cleanup

    show_message
}

# The initialisation function
init() {
    # -------------------------- Constants -------------------------------------
    s_user_csadmin="csadmin"
    s_password_csadmin="changeme"

    d_tmp="/tmp"
    d_yum_repo="/etc/yum.repos.d/"
    f_rhel_repo="redhat.repo"
    a_edition=("enterprise" "secure-message-exchange")
    f_etc_environment="/etc/environment"
    f_os_release="/etc/os-release"
    f_sshd_config="/etc/ssh/sshd_config"
    d_cypto_policies_back_ends="/etc/crypto-policies/back-ends"
    l_ssh_config_files="
    openssh.config \
    libssh.config \
    nss.config \
    opensshserver.config
    "
    sudoers="/etc/sudoers"
    s_group_wheel="wheel"
    s_product_release_version=7.4.0
    s_product_build_number=3024
    f_cyops_release="/etc/cyops-release"
    s_product_yum_server="repo.fortisoar.fortinet.com"
    l_supported_os_for_install=("Rocky Linux" "Red Hat Enterprise Linux")
    flag_ignore_ssl_check_curl="-Is"
    f_fstab="/etc/fstab"
    s_php_ver="8.0"
    s_nodejs_ver="14"
    # If the user entered the empty more than three-times, then the i_count variable value will increase and exit the script — initially, i_count set to 0.
    i_count=0
    # Skip the SOAR framework solution pack. true: skip to install, false: install
    skip_install_sfsp="false"
    # Enter user y or n.
    s_user_input=""
    flag_user_in_wheel_grp="false"
    s_logged_in_user=$(logname)
    # The "flag_custom_yum_url" for user's offline repo.
    # The variable value false: not exported the offline repo.
    # The variable value true: exported the offline repo.
    flag_custom_yum_url="false"

    # i_check_volumes=0 All volumes are exist.
    # i_check_volumes=1 The volumes are not exist or exit but not as per recommended size.
    i_check_volumes=0

    # flag_expire_csadmin_password will be set by caller code of this script
    # Ex: auto vul scan etc which requires config vm to be run automatically after installation
    # If password is expired then further ssh logins keep prompting for changing the password and then
    # automation fails. Hence the change.
    if [ -z "$flag_expire_csadmin_password" ];then
        # flag_expire_csadmin_password is empty so set it to "true" as default value
        flag_expire_csadmin_password="true"
    fi

    # The flag_is_csadmin_user_exist flag is to check if csadmin user exists or not, before starting the installation.
    flag_is_csadmin_user_exist=$(is_csadmin_user_exist)
    if [ "$flag_is_csadmin_user_exist" = "true" ] ; then
        # Do not expire the csadmin password if csadmin user exists before FortiSOAR installation
        flag_expire_csadmin_password="false"
    fi

    for input_arg in "$@"
    do
        if [ "$input_arg" = "--ignore-ssl-check"  ]; then
            flag_ignore_ssl_check_curl="-Isk"
        elif [ "$input_arg" = "--skip-sfsp"  ]; then
            skip_install_sfsp="true"
        elif [ "$input_arg" = "--help"  ]; then
            usage
        else
            echo "Error: Unknown parameter - $input_arg"
            usage
        fi
    done

    # Detect hypervisor type
    s_hypervisor_detected=$(dmesg | grep -i "Hypervisor detected" | cut -d: -f2 | xargs)
    case $s_hypervisor_detected in
        "VMware")
            s_hypervisor_type="vmware"
        ;;

        "Xen HVM")
            s_hypervisor_type="aws"
        ;;

        "Microsoft Hyper-V")
            s_hypervisor_type="azure"
        ;;

    esac

    flag_is_rhel="false"
    check_if_rhel

    # -------------------------- Constants End ---------------------------------

    d_home_csadmin="/home/$s_user_csadmin"

    # Help doc url
    s_help_doc="https://docs.fortinet.com/document/fortisoar/${s_product_release_version}/deployment-guide"

    # Get major version of os release
    i_version_os=$(grep "^\s*VERSION_ID=" $f_os_release | sed 's|VERSION_ID="\([0-9]*\)\..*|\1|g')
    emulation_layer=el$i_version_os

    d_backup_repo_file=$d_home_csadmin/backup_repo_file

    if [ ! -z "$custom_yum_url" ]; then
        flag_custom_yum_url="true"
        s_product_yum_server_old=$s_product_yum_server
    fi

# Payload details below
cyops_repo_update_7_4_0_el8_x86_64_rpm=cyops-repo-update-7.4.0.el8.x86_64.rpm
cyops_repo_update_7_4_0_el8_x86_64_rpm_sha512=0eb0642ad989472f1846886e69a10d0274de3b61507b695c506ab9025e70409385b430794802478470ba1129d4ac648094725d769e3506f4da14097ff554eeae
cyops_repo_update_7_4_0_el8_x86_64_rpm_size=8792

payload_size=8792

file_vars_list=" cyops_repo_update_7_4_0_el8_x86_64_rpm"
# End of payload details
    i_bytes_to_skip=$(awk '/^__PAYLOAD_STARTS_AFTER_THIS__/ { print NR; exit 0; }' $0)
    c_first_char=$(echo $0 | cut -c 1)
    if [ "$c_first_char" = "/" ]; then
        script=$0
    else
        script=$(pwd)/$0
    fi
    export script
    export i_bytes_to_skip

    # fsr_edition is an environment variable
    # If it is non-empty, set flag_interactive_install to true
    # and use flag_interactive_install in the script to check if its interactive installation or not
    if [ ! -z "$fsr_edition" ]; then
        flag_interactive_install="false"
        if [ "$fsr_edition" != "enterprise" -a "$fsr_edition" != "sme" ]; then
            # Only 1 and 2 are supported as valid values for fsr_edition
            # fsr_edition is set to empty in case any other value is found
            # In which case, user is prompted for input
            echo "Value of fsr_edition is invalid: $fsr_edition"
            echo "User will be prompted to input the edition type"
            fsr_edition=""
            flag_interactive_install="true"
        else
            if [ "$fsr_edition" = "enterprise" ]; then
                i_edition=1
            elif [ "$fsr_edition" = "sme" ]; then
                i_edition=2
            fi
        fi
    else
        flag_interactive_install="true"
    fi
}

#######
# MAIN
#######
init $@

if [ "$1" = "extract" ]; then
    extract_archive
    my_exit 0
fi

get_edition

pre_install_check

pre_install

install

post_install

my_exit 0

__PAYLOAD_STARTS_AFTER_THIS__
 od yxdӃ^\*Ld2,-TJ f7,3! QE,".[
Vt]YkEDYe9  k-T,_铼$1}#jAAPBAY4q6|DyΦo<NnBXqq]<h[7G0E$	OH7oQNvjoL"JvO]&+"Z2kڣQ2 a_i2,qWj !1GaY剠U>{d집}>4;dEDsv\D3E7ȴ]KXp0K @`#-,^U\s~ʾ;ڷev}K/`0`0+=2"}<L}%'|I&HC#ǑB\GIG7O")W	"=*o"}ː> ҕHH_DCُ!}QsKHZ4^YiDu	-3Vtk?vm=dh[;#5;MAr#wHwt|Zi٨T#GZFBLTߐm|?❌집jP,{\G!}c7i@ZAz=>6!"C&O~]T_?bDKfd!D4~:F:hJDWjjN	ܱdPMM/%*߬D.Ճ~*mMy5ätM^SmZFj $o@i*0+ٺU`z)!pJfh>LA^6I#$UQLxM3hۋm?sLXtYI*HڋD[G]%J"!*\5x{Ȃ]h"1rFHHSI^L^5슡DP )WPz+XFF2&J8ؠ!̇a[FPÏvg7kT4LMNG7y6h%LR%A@6H/Э(8/}s_	E2#p<É-r:<
G{M[\nVvN$ \
+8ir9E)0#2`<tp(.82
'ˬB;hfXw32/ђ[v9DZNEpNݲ(n88Xı.ʂCe!p7 @s:ff^to:6Co{Mh>K50s3$|.a%S؈OMA3l5N_-3B-y5/[,ib%l(j/͙Fp(m(l<p>;mll\o^$97;N#ZK4͟Uu?L-\CDhkӫ2uʼvvbIΥj$8h躦C/0?85abf	iCc2I=吔J$4<c@Ǥ4c\w(Ե lP-$(VMW#*(C!lcg+(. )Ibn]4
-o?
!]`|Q0&-dP@)S%hxo4HJMHAU#Jf,Z(ԺC
1<'-34AI}vڔm@uK]' \I8jTxG- _. %-X7 Ť չY;2Fa#WM ҵ;٬_4eST(`4$QpE%dbD9nNT8	N7`/P|53M:SQafwܟ] z_Wێi}Wx6փ/헿Y_^[:pe`7VBfsmYǅ	޻u(c?CYy擔,w-$>v=;O_r?tZWU}S>q.KJNlxxuObV7Ĭmgkgdg;X;ݏU=6U6ﳕ?񓹫8fP)/ϭ/|G~Zhi;O&~'eT	zw|L볮dn)(?kemk.H<Eo,]=ߧKl11oRٞSn|+?Vy[׶2#`󫒏O]ȟ\R7,;Ur;aު~zK/%:+挭wWV<\bך'Zbc/3>`K;m~֟Z1w?~dhϣ\vxOT>HNo^9x:ZPy#<VmM⏄=yչ1_~aʼܹ>ΜxPZEHk۩LYT2fHnIfG%zjʾ]۫_UV~|܅>o[ת㫄o'7f`.6cV7}Ɏ)Z?k;?^޽6}?=Xj`w;:YìS%~_<^ޙ$:lModv[zX%e\sFe}2:^ѝz3n;0ͣ6I$MrI`0`0`0`0`0j! P  